<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title><em>The Statistical Eye: Patterns in visual inferences</em></title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1><em>The Statistical Eye: Patterns in visual inferences</em></h1>

<h2>Omesh Johar</h2>

<h2>STAT 585X Project Proposal</h2>

<p><strong>Topic</strong></p>

<p>This project is an attempt to explore ways in which visual inferences are drawn.</p>

<p><strong>Motivation</strong></p>

<p>Visual inference refers to the act (and the outcome) of drawing a statistical inference based on a visualization of data. Numerical statistics are not always available. Often, people need to draw inferences based on visual representations of data. However, more research is needed to understand the process by which people draw visual inferences.</p>

<p><strong>Questions</strong></p>

<p>Are there any patterns in the way in which visual inferences are drawn? When presented with visual representations, how long do people take to form an inference? In doing so, do people sequentially go from one image to another, noticing minute details of every image? Or, is it a more top-down process, whereby people try to chunk different images based on certain attributes and later study every group? These are some of the questions of interest.</p>

<p><strong>Data</strong></p>

<p>Twenty-four students participated in an eye-tracking study. Each participant looked at nine line-ups of plots. For each line-up, participants selected a plot which was the &ldquo;odd-one-out&rdquo;. Available data contain information about the x-y coordinates of their gaze (both eyes) along with time-stamps. Data for each combination of line-up and participant appear in a different file. This study was conducted by Dr. Dianne Cook and her colleagues. She will make the data available.  </p>

<p><strong>Tasks</strong>
Data from different line-ups for each participant need to be collated and merged before processing. Therefore, I anticipate the use of &ldquo;melting&rdquo;, aggregation, summarization, etc. Processing would involve identification of patterns in the way each participant arrived at an inference. Thus, I will examine the flow of gaze from one plot to another. In so doing, I will rely on the total time spent on a line-up, time spent on each plot, parts of each plot that participants paid attention to, and so on. </p>

<p>Given below is some R code which helps creating a usable data file from raw data from a participant (courtesy: Dr. Dianne Cook). </p>

<pre><code class="r">ET &lt;- function(pdf) {
    library(ggplot2)
    data.path &lt;- file.path(file.choose())
    data &lt;- read.csv(data.path)
    data.name &lt;- unlist(strsplit(unlist(basename(data.path)), &quot;.csv&quot;))
    data.people &lt;- unlist(strsplit(data.name, &quot;_&quot;))[1]
    data.test &lt;- unlist(strsplit(data.name, &quot;_&quot;))[2]
    data.choose &lt;- as.numeric(unlist(strsplit(data.name, &quot;_&quot;))[3])
    data$people &lt;- data.people
    data$test &lt;- data.test
    data$choose &lt;- data.choose
    data$Time2 &lt;- 1:nrow(data)
    data$Time3 &lt;- data$Time2%/%86 + 1
    data &lt;- unique(data)
    data$Xdiff &lt;- abs(data$Left.Gaze.Point.X - data$Right.Gaze.Point.X)
    data$Ydiff &lt;- abs(data$Left.Gaze.Point.Y - data$Right.Gaze.Point.Y)
    data$Gaze.X &lt;- 0.5 * (data$Left.Gaze.Point.X + data$Right.Gaze.Point.X)
    data$Gaze.Y &lt;- 0.5 * (data$Left.Gaze.Point.Y + data$Right.Gaze.Point.Y)
    data$Ignore &lt;- 1
    data[data$Xdiff &lt; mean(data$Xdiff) + qnorm(0.9) * sd(data$Xdiff) &amp; data$Ydiff &lt; 
        mean(data$Ydiff) + qnorm(0.9) * sd(data$Ydiff), ]$Ignore &lt;- 0
    nX &lt;- 5
    nY &lt;- 4
    lengthX &lt;- 1680
    lengthY &lt;- 1050
    if (data.test %in% c(&quot;D3&quot;, &quot;D4&quot;, &quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;, &quot;M4&quot;, &quot;M5&quot;, &quot;M6&quot;, &quot;M7&quot;, 
        &quot;M8&quot;)) {
        X.Start &lt;- lengthX/2 - lengthY * (1040/1080)/2 + lengthY * (67/1080)
        Y.Start &lt;- lengthY * 0 + lengthY * (20/1080)
        X.End &lt;- lengthX/2 - lengthY * (1040/1080)/2 + lengthY * (1015/1080)
        Y.End &lt;- lengthY * 0 + lengthY * (1020/1080)
        X.Range &lt;- (X.End - X.Start)/nX
        Y.Range &lt;- (Y.End - Y.Start)/nY
    }
    if (data.test %in% c(&quot;D1&quot;, &quot;D2&quot;)) {
        X.Start &lt;- lengthX/2 - lengthY * (1292/1080)/2 + lengthY * (36/1080)
        Y.Start &lt;- lengthY * 0 + lengthY * (20/1080)
        X.End &lt;- lengthX/2 - lengthY * (1292/1080)/2 + lengthY * (1270/1080)
        Y.End &lt;- lengthY * 0 + lengthY * (1020/1080)
        X.Range &lt;- (X.End - X.Start)/nX
        Y.Range &lt;- (Y.End - Y.Start)/nY
    }
    data$Plot &lt;- 0
    data$Row &lt;- 0
    data$Col &lt;- 0

    ###### test
    data[data$Gaze.X &gt;= X.Start &amp; data$Gaze.X &lt;= X.End, ]$Col &lt;- (data[data$Gaze.X &gt;= 
        X.Start &amp; data$Gaze.X &lt;= X.End, ]$Gaze.X - X.Start)%/%X.Range + 1
    data[data$Gaze.Y &gt;= Y.Start &amp; data$Gaze.Y &lt;= Y.End, ]$Row &lt;- (data[data$Gaze.Y &gt;= 
        Y.Start &amp; data$Gaze.Y &lt;= Y.End, ]$Gaze.Y - Y.Start)%/%Y.Range + 1
    data[(data$Row * data$Col) != 0, ]$Plot &lt;- data[(data$Row * data$Col) != 
        0, ]$Col + nX * (data[(data$Row * data$Col) != 0, ]$Row - 1)
    data$Plot &lt;- as.character(data$Plot)
    data$Plot &lt;- as.numeric(data$Plot)
    data$Pass &lt;- 0
    for (i in 3:(nrow(data) - 2)) data$Pass[i] &lt;- (data$Plot[i - 1] - data$Plot[i - 
        2])^2 + (data$Plot[i] - data$Plot[i - 1])^2 + (data$Plot[i + 1] - data$Plot[i])^2 + 
        (data$Plot[i + 2] - data$Plot[i + 1])^2
    data$Plot &lt;- as.character(data$Plot)
    data[data$Pass != 0, ]$Pass &lt;- 9999
    data$Pass[c(1, 2, nrow(data) - 1, nrow(data))] &lt;- 9999
    data$Pass[which(data$Pass != 9999)][1] &lt;- 1
    for (i in 2:length(which(data$Pass != 9999))) data[data$Pass != 9999, ]$Pass[i] &lt;- if (which(data$Pass != 
        9999)[i] == (which(data$Pass != 9999)[i - 1] + 1)) 
        data$Pass[which(data$Pass != 9999)][i - 1] else (data$Pass[which(data$Pass != 9999)][i - 1] + 1)
    data$Pupil &lt;- 0
    data[data$Left.Pupil.Diameter..mm. &gt; 0 &amp; data$Right.Pupil.Diameter..mm. &gt; 
        0, ]$Pupil &lt;- (data[data$Left.Pupil.Diameter..mm. &gt; 0 &amp; data$Right.Pupil.Diameter..mm. &gt; 
        0, ]$Left.Pupil.Diameter..mm. + data[data$Left.Pupil.Diameter..mm. &gt; 
        0 &amp; data$Right.Pupil.Diameter..mm. &gt; 0, ]$Right.Pupil.Diameter..mm.)/2
    data$Choose &lt;- 1
    data[data$Plot != data.choose, ]$Choose &lt;- 0
    data$Choose &lt;- as.character(data$Choose)
    data &lt;- data[data$Ignore == 0 &amp; data$Pass != 9999 &amp; data$Plot != 0 &amp; data$Pupil &gt; 
        0, ]
    if (pdf == T) {
        line.X &lt;- geom_vline(x = c(X.Start, X.Start + X.Range, X.Start + X.Range * 
            2, X.Start + X.Range * 3, X.Start + X.Range * 4, X.Start + X.Range * 
            5), colour = I(&quot;white&quot;))
        line.Y &lt;- geom_hline(y = c(-Y.Start, -Y.Start - Y.Range, -Y.Start - 
            Y.Range * 2, -Y.Start - Y.Range * 3, -Y.Start - Y.Range * 4), colour = I(&quot;white&quot;))
        p1 &lt;- qplot(Gaze.X, -Gaze.Y, data = data, alpha = I(0.3), size = Pupil/4, 
            colour = Plot, xlim = c(0, lengthX), ylim = c(-lengthY, 0), xlab = &quot;X&quot;, 
            ylab = &quot;Y&quot;, main = &quot;Eye Position Coloured by Plots&quot;)
        p1 + line.X + line.Y
        ggsave(paste(data.name, &quot;_plot1.pdf&quot;), width = 16, height = 10)
    }
    if (pdf == F) {
    }
    data &lt;- data
}
</code></pre>

<p>The following code creates a data frame with the raw data from a participant:</p>

<pre><code class="r">participant_data &lt;- ET(T)
</code></pre>

<pre><code>## Error: file choice cancelled
</code></pre>

</body>

</html>

